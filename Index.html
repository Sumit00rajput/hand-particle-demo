<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Controlled 3D Particles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin:0; overflow:hidden; background:black; }
  video { display:none; }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>
/* ===================== THREE SCENE ===================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 120;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ===================== PARTICLES ===================== */
const COUNT = 25000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

let shapeIndex = 0;
let lastSwitch = 0;

/* ========== SHAPES ========== */
function heart(t){
  return {
    x:16*Math.pow(Math.sin(t),3),
    y:13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t),
    z:0
  };
}

function saturn(t){
  return {
    x:Math.cos(t)*28,
    y:Math.sin(t*0.5)*8,
    z:Math.sin(t)*28
  };
}

function flower(t){
  return {
    x:Math.cos(t)*Math.sin(6*t)*30,
    y:Math.sin(t)*Math.sin(6*t)*30,
    z:Math.cos(6*t)*8
  };
}

function fireworks(){
  const a = Math.random()*Math.PI*2;
  const b = Math.random()*Math.PI;
  return {
    x:Math.sin(b)*Math.cos(a)*35,
    y:Math.sin(b)*Math.sin(a)*35,
    z:Math.cos(b)*35
  };
}

const shapes = [heart, saturn, flower, fireworks];

function updateShape(){
  for(let i=0;i<COUNT;i++){
    const t = (i/COUNT)*Math.PI*2;
    const p = shapeIndex === 3 ? fireworks() : shapes[shapeIndex](t);

    positions[i*3]   = p.x;
    positions[i*3+1] = p.y;
    positions[i*3+2] = p.z;

    colors[i*3]   = Math.random();
    colors[i*3+1] = Math.random();
    colors[i*3+2] = Math.random();
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));
updateShape();

/* ===================== MATERIAL ===================== */
const material = new THREE.ShaderMaterial({
  uniforms:{ uExpand:{ value:1.0 } },
  vertexShader:`
    uniform float uExpand;
    attribute vec3 color;
    varying vec3 vColor;
    void main(){
      vColor = color;
      vec3 p = position * uExpand;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
      gl_PointSize = 2.2;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    void main(){
      gl_FragColor = vec4(vColor,1.0);
    }
  `,
  vertexColors:true
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ===================== MEDIAPIPE ===================== */
const video = document.getElementById("video");

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

hands.onResults(res=>{
  if(!res.multiHandLandmarks) return;

  const h = res.multiHandLandmarks[0];
  const pinch = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);

  material.uniforms.uExpand.value = THREE.MathUtils.lerp(
    material.uniforms.uExpand.value,
    THREE.MathUtils.clamp(1.8 - pinch*4, 0.6, 3),
    0.12
  );

  if(pinch < 0.035 && Date.now() - lastSwitch > 900){
    shapeIndex = (shapeIndex + 1) % shapes.length;
    updateShape();
    lastSwitch = Date.now();
  }
});

const cam = new Camera(video,{
  onFrame: async()=>{ await hands.send({image:video}); },
  width:640, height:480
});
cam.start();

/* ===================== ANIMATION ===================== */
function animate(){
  requestAnimationFrame(animate);
  particles.rotation.y += 0.0015;
  particles.rotation.x += 0.0007;
  renderer.render(scene,camera);
}
animate();

/* ===================== RESIZE ===================== */
window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
